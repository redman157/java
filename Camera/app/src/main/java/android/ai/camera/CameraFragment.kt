package android.ai.camera

import android.ai.camera.databinding.FragmentCameraBinding
import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.res.Configuration
import android.graphics.*
import android.hardware.camera2.*
import android.hardware.camera2.params.StreamConfigurationMap
import android.media.ExifInterface
import android.media.Image
import android.media.ImageReader
import android.net.Uri
import android.os.*
import android.provider.MediaStore
import android.util.Log
import android.util.Size
import android.util.SparseIntArray
import android.view.*
import android.view.TextureView.SurfaceTextureListener
import android.widget.ImageButton
import android.widget.RelativeLayout
import androidx.fragment.app.Fragment
import com.bumptech.glide.Glide
import com.bumptech.glide.load.engine.DiskCacheStrategy
import com.bumptech.glide.request.RequestOptions
import com.google.android.material.snackbar.Snackbar
import java.io.File
import java.io.IOException
import java.util.*
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit

/**
 * A simple [Fragment] subclass.
 * Use the [CameraFragment.newInstance] factory method to
 * create an instance of this fragment.
 */
class CameraFragment : Fragment(), View.OnClickListener, View.OnTouchListener{
    //vars
    /** A [Semaphore] to prevent the app from exiting before closing the camera.  */
    private val mCameraOpenCloseLock = Semaphore(1)

    /** A [CameraCaptureSession] for camera preview.  */
    private val mCaptureSession: CameraCaptureSession? = null

    /** A reference to the opened [CameraDevice].  */
    private var mCameraDevice: CameraDevice? = null

    /** ID of the current [CameraDevice].  */
    private lateinit var mCameraId: String

    /** The [android.util.Size] of camera preview.  */
    private var mPreviewSize: Size? = null

    /** Orientation of the camera sensor  */
    private var mSensorOrientation = 0

    /** An [ScalingTextureView] for camera preview.  */
    private lateinit var mTextureView: ScalingTextureView

    /** [CaptureRequest.Builder] for the camera preview  */
    private val mPreviewRequestBuilder: CaptureRequest.Builder? = null

    /** [CaptureRequest] generated by [.mPreviewRequestBuilder]  */
    private val mPreviewRequest: CaptureRequest? = null

    /** An additional thread for running tasks that shouldn't block the UI.  */
    private val mBackgroundThread: HandlerThread? = null

    /** A [Handler] for running tasks in the background.  */
    private val mBackgroundHandler: Handler? = null

    /** An [ImageReader] that handles still image capture.*/
    private var mImageReader: ImageReader? = null

    /** Max preview width that is guaranteed by Camera2 API  */
    private val MAX_PREVIEW_WIDTH = 1920

    /** Max preview height that is guaranteed by Camera2 API  */
    private val MAX_PREVIEW_HEIGHT = 1080

    private var SCREEN_WIDTH = 0

    private var SCREEN_HEIGHT = 0

    private val ASPECT_RATIO_ERROR_RANGE = 0.1f

    private var mCapturedImage: Image? = null

    private val mIsImageAvailable = false

    private lateinit var mIMainActivity: IMainActivity

    private var mCapturedBitmap: Bitmap? = null

    private val mBackgroundImageRotate: BackgroundImageRotate? = null

    private val mIsDrawingEnabled = false

    var mIsCurrentlyDrawing = false

    private val mFlashState = 0

    private var mFlashSupported = false

    private lateinit var mContext : Context

    private lateinit var mBinding: FragmentCameraBinding

    /** widgets */
    private lateinit var mStillShotContainer: RelativeLayout
    private lateinit var mFlashContainer: RelativeLayout
    private lateinit var mSwitchOrientationContainer: RelativeLayout
    private lateinit var mCaptureBtnContainer: RelativeLayout
    private lateinit var mCloseStillShotContainer: RelativeLayout
    private lateinit var mPenContainer: RelativeLayout
    private lateinit var mUndoContainer: RelativeLayout
    private lateinit var mColorPickerContainer: RelativeLayout
    private lateinit var mSaveContainer: RelativeLayout
    private lateinit var mStickerContainer: RelativeLayout
    private lateinit var mTrashContainer: RelativeLayout
    private lateinit var mStillShotImageView: DrawableImageView
    private lateinit var mTrashIcon: ImageButton
    private lateinit var mFlashIcon:ImageButton
    private lateinit var mVerticalSlideColorPicker: VerticalSlideColorPicker
    override fun onAttach(context: Context) {
        super.onAttach(context)
        mContext = context
        try {
            mIMainActivity = (activity as IMainActivity)
        } catch (e: ClassCastException) {
            Log.e(
                TAG, "onAttach: ClassCastException: " + e.message
            )
        }

    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        mBinding = FragmentCameraBinding.inflate(layoutInflater)
        return mBinding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        mBinding.stillshot.setOnClickListener(this)
        mBinding.flashToggle.setOnClickListener(this)
        mBinding.switchOrientation.setOnClickListener(this)
        mBinding.initDrawIcon.setOnClickListener(this)
        mBinding.saveStillshot.setOnClickListener(this)
        mBinding.initStickerIcon.setOnClickListener(this)
        mBinding.closeStillshotView.setOnClickListener(this)
        mBinding.trash.setOnClickListener(this)
        mBinding.undoContainer.setOnClickListener(this)
        mBinding.stillshotImageview.setOnClickListener(this)
        mBinding.cameraContainer.setOnTouchListener(this)
        
        mColorPickerContainer = mBinding.colorPickerContainer
        mCloseStillShotContainer = mBinding.closeStillshotView
        mTrashContainer = mBinding.trashContainer
        mTrashIcon = mBinding.trash
        mFlashIcon = mBinding.flashToggle
        mFlashContainer = mBinding.flashContainer

        mStickerContainer = mBinding.stickerContainer
        mSaveContainer = mBinding.saveContainer
        mUndoContainer = mBinding.undoContainer
        mPenContainer = mBinding.penContainer

        mStillShotContainer = mBinding.stillshotContainer
        mStillShotImageView = mBinding.stillshotImageview
        mSwitchOrientationContainer = mBinding.switchOrientationContainer
        mCaptureBtnContainer = mBinding.captureButtonContainer
        mTextureView = mBinding.cameraContainer
        setMaxSizes()
        resetIconVisibilities()
    }

    override fun onResume() {
        super.onResume()
    }

    override fun onPause() {
        super.onPause()
    }

    private fun setMaxSizes(){
        val displaySize = Point()
        activity!!.windowManager.defaultDisplay.getSize(displaySize)
        SCREEN_HEIGHT = displaySize.x
        SCREEN_WIDTH = displaySize.y

        Log.d(TAG, "setMaxSizes: screen width:$SCREEN_WIDTH")
        Log.d(TAG, "setMaxSizes: screen height: $SCREEN_HEIGHT")
    }

    private fun resetIconVisibilities(){
        mColorPickerContainer.visibility = View.INVISIBLE
        mUndoContainer.visibility = View.INVISIBLE
        mStillShotContainer.visibility = View.INVISIBLE
        mPenContainer.visibility = View.VISIBLE
        mStickerContainer.visibility = View.VISIBLE

        mFlashContainer.visibility = View.VISIBLE
        mSwitchOrientationContainer.visibility = View.VISIBLE
        mCaptureBtnContainer.visibility = View.VISIBLE
        mTrashContainer.visibility = View.INVISIBLE
    }
    /**
     * WARNING!
     * Can cause memory leaks! To prevent this the object is a global and CANCEL is being called
     * in "OnPause".
     */
    private inner class BackgroundImageRotate(var mActivity: Activity) : AsyncTask<Void?, Int?, Int>() {
        override fun doInBackground(vararg voids: Void?): Int {
            Log.d(TAG, "doInBackground: adjusting image for display...")
            val file = File(mActivity.getExternalFilesDir(null), "temp_image.jpg")
            val tempImageUri = Uri.fromFile(file)
            var bitmap: Bitmap? = null
            try {
                val exif = ExifInterface(tempImageUri.path!!)
                if (Build.VERSION.SDK_INT >= 29) {
                    val source: ImageDecoder.Source = ImageDecoder.createSource(
                        mActivity.contentResolver,
                        tempImageUri
                    )
                    try {
                        bitmap = ImageDecoder.decodeBitmap(source)
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                } else {
                    try {
                        bitmap = MediaStore.Images.Media.getBitmap(
                            mActivity.contentResolver,
                            tempImageUri
                        )
                    } catch (e: IOException) {
                        e.printStackTrace()
                    }
                }
                val orientation = exif.getAttributeInt(
                    ExifInterface.TAG_ORIENTATION,
                    ExifInterface.ORIENTATION_UNDEFINED
                )
                mCapturedBitmap = bitmap?.let {
                    rotateBitmap(it, orientation)
                }
            } catch (e: IOException) {
                e.printStackTrace()
                return 0
            }
            return 1
        }

        override fun onPostExecute(integer: Int?) {
            super.onPostExecute(integer)
            if (integer == 1) {
                displayCapturedImage()
            } else {
                (mContext as MainActivity).showSnackBar(
                    "Error preparing image",
                    Snackbar.LENGTH_SHORT
                )
            }
        }
    }

    private fun rotateBitmap(bitmap: Bitmap, orientation: Int): Bitmap?{
        val matrix = Matrix()
        when (orientation) {
            ExifInterface.ORIENTATION_TRANSPOSE -> {
                Log.d(TAG, "rotateBitmap: transpose")
                matrix.setRotate(90f)
                matrix.postScale(-1f, 1f)
            }
            ExifInterface.ORIENTATION_NORMAL -> {
                Log.d(TAG, "rotateBitmap: normal.")
                return bitmap
            }
            ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> {
                Log.d(TAG, "rotateBitmap: flip horizontal")
                matrix.setScale(-1f, 1f)
            }
            ExifInterface.ORIENTATION_ROTATE_180 -> {
                Log.d(TAG, "rotateBitmap: rotate 180")
                matrix.setRotate(180f)
            }
            ExifInterface.ORIENTATION_FLIP_VERTICAL -> {
                Log.d(TAG, "rotateBitmap: rotate vertical")
                matrix.setRotate(180f)
                matrix.postScale(-1f, 1f)
            }
            ExifInterface.ORIENTATION_ROTATE_90 -> {
                Log.d(TAG, "rotateBitmap: rotate 90")
                matrix.setRotate(90f)
            }
            ExifInterface.ORIENTATION_TRANSVERSE -> {
                Log.d(TAG, "rotateBitmap: transverse")
                matrix.setRotate(-90f)
                matrix.postScale(-1f, 1f)
            }
            ExifInterface.ORIENTATION_ROTATE_270 -> {
                Log.d(TAG, "rotateBitmap: rotate 270")
                matrix.setRotate(-90f)
            }
        }
        return try {
            if (mIMainActivity.isCameraFrontFacing()) {
                Log.d(TAG, "rotateBitmap: MIRRORING IMAGE.")
                matrix.postScale(-1.0f, 1.0f)
            }
            val bmRotated =
                Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true)
            bitmap.recycle()
            bmRotated
        } catch (e: OutOfMemoryError) {
            e.printStackTrace()
            null
        }
    }

    private fun displayCapturedImage(){
        Log.d(TAG, "displayCapturedImage: displaying stillshot image.")
        (mContext as Activity).runOnUiThread {
            val options: RequestOptions = RequestOptions()
                .diskCacheStrategy(DiskCacheStrategy.NONE)
                .skipMemoryCache(true)
                .centerCrop()

            val bitmapWidth = mCapturedBitmap!!.width
            val bitmapHeight = mCapturedBitmap!!.height

            Log.d(TAG, "run: captured image width: $bitmapWidth")
            Log.d(TAG, "run: captured image height: $bitmapHeight")


            var focusX = mTextureView!!.mFocusX.toInt()
            var focusY = mTextureView.mFocusY.toInt()
            Log.d(TAG, "run: focusX: $focusX")
            Log.d(TAG, "run: focusY: $focusY")


            val maxWidth = mTextureView.width
            val maxHeight = mTextureView.height
            Log.d(TAG, "run: initial maxWidth: $maxWidth")
            Log.d(TAG, "run: initial maxHeight: $maxHeight")

            val bitmapHeightScaleFactor = bitmapHeight.toFloat() / maxHeight.toFloat()
            val bitmapWidthScaleFactor = bitmapWidth.toFloat() / maxWidth.toFloat()
            Log.d(TAG, "run: bitmap width scale factor: $bitmapWidthScaleFactor")
            Log.d(TAG, "run: bitmap height scale factor: $bitmapHeightScaleFactor")

            val actualWidth = (maxWidth * (1 / mTextureView.mScaleFactorX)).toInt()
            val actualHeight = (maxHeight * (1 / mTextureView.mScaleFactorY)).toInt()
            Log.d(TAG, "run: actual width: $actualWidth")
            Log.d(TAG, "run: actual height: $actualHeight")

            val scaledWidth = (actualWidth * bitmapWidthScaleFactor).toInt()
            val scaledHeight = (actualHeight * bitmapHeightScaleFactor).toInt()
            Log.d(TAG, "run: scaled width: $scaledWidth")
            Log.d(TAG, "run: scaled height: $scaledHeight")

            focusX *= bitmapWidthScaleFactor.toInt()
            focusY *= bitmapHeightScaleFactor.toInt()

            var background: Bitmap? = null
            background = Bitmap.createBitmap(
                mCapturedBitmap!!,
                focusX,
                focusY,
                scaledWidth,
                scaledHeight
            )


            mStillShotImageView?.let {
                Glide.with(mContext)
                    .setDefaultRequestOptions(options)
                    .load(background)
                    .into(it)
            }

//            showStillshotContainer()
        }

    }

    /**
     * Open Camera when open app
     **/
    private fun reopenCamera(){
        Log.d(TAG, "reopenCamera: called.")
        if (mTextureView.isAvailable){
            Log.d(TAG, "reopenCamera: a surface is available.")
            openCamera(mTextureView.width, mTextureView.height)
        }else{
            Log.d(TAG, "reopenCamera: no surface is available.")
            mTextureView.surfaceTextureListener = mSurfaceTextureListener
        }
    }

    @SuppressLint("MissingPermission")
    private fun openCamera(width: Int, height: Int){
        var activity : Activity = mContext as Activity
        val manager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
        setUpCameraOutputs(width, height, manager)
        configureTransform(width, height)
        try {
            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw RuntimeException("Time out waiting to lock camera opening.")
            }
            manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler)
        }catch (e: CameraAccessException){
            Log.d(TAG, "OpenCamera --- CameraAccessException: ${e.message}")
        }catch (e: InterruptedException){
            Log.d(TAG, "OpenCamera --- InterruptedException: ${e.message}")
        }
    }

    /**
     * Sets up member variables related to camera.
     *
     * @param width  The width of available size for camera preview
     * @param height The height of available size for camera preview
     */
    @SuppressWarnings("SuspiciousNameCombination")
    private fun setUpCameraOutputs(width: Int, height: Int, manager: CameraManager){
        try {
            Log.d(TAG, "setUpCameraOutputs: called.")
            if (!(mContext as MainActivity).isCameraFrontFacing() && !(mContext as MainActivity).isCameraFrontFacing()){
                Log.d(TAG, "setUpCameraOutputs: finding camera id's.")
                findCameraIds(manager)
            }
            val characteristics: CameraCharacteristics = manager.getCameraCharacteristics(mCameraId)
            val map: StreamConfigurationMap? = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
            map?.let {
                var largest: Size? = null
                val screenAspectRatio = SCREEN_WIDTH.toFloat() / SCREEN_HEIGHT.toFloat()
                val sizes: ArrayList<Size> = ArrayList()
                for (size in listOf(map.getOutputSizes(ImageFormat.JPEG))){
                    (size as Size)
                    val temp: Float = size.width.toFloat() / size.height.toFloat()
                    Log.d(TAG, "setUpCameraOutputs: temp: $temp")
                    Log.d(TAG, "setUpCameraOutputs: w: " + size.width + ", h: " + size.height)
                    if (temp > screenAspectRatio - screenAspectRatio * ASPECT_RATIO_ERROR_RANGE
                        && temp < screenAspectRatio + screenAspectRatio * ASPECT_RATIO_ERROR_RANGE) {
                        sizes.add(size)
                        Log.d(
                            TAG,
                            "setUpCameraOutputs: found a valid size: w: " + size.width + ", h: " + size.height
                        )
                    }
                }
                if (sizes.size > 0) {
                    largest = Collections.max(sizes, CompareSizesByArea())
                    Log.d(TAG, "setUpCameraOutputs: largest width:  ${largest.width}")
                    Log.d(TAG, "setUpCameraOutputs: largest height:  ${largest.height}")
                }

                // Find out if we need to swap dimension to get the preview size relative to sensor
                // coordinate.

                // Find out if we need to swap dimension to get the preview size relative to sensor
                // coordinate.
                val displayRotation = activity!!.windowManager.defaultDisplay.rotation
                //noinspection ConstantConditions
                mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION)!!
                var swappedDimensions = false
                when (displayRotation) {
                    Surface.ROTATION_0, Surface.ROTATION_180 -> {
                        swappedDimensions = mSensorOrientation == 90 || mSensorOrientation == 270
                    }
                    Surface.ROTATION_90, Surface.ROTATION_270 -> {
                        swappedDimensions = mSensorOrientation == 0 || mSensorOrientation == 180
                    }
                    else -> Log.e(TAG, "Display rotation is invalid: $displayRotation")
                }
                val displaySize = Point()
                activity!!.windowManager.defaultDisplay.getSize(displaySize)
                var rotatedPreviewWidth = width
                var rotatedPreviewHeight = height
                var maxPreviewWidth = displaySize.x
                var maxPreviewHeight = displaySize.y

                if (swappedDimensions) {
                    rotatedPreviewWidth = height
                    rotatedPreviewHeight = width
                    maxPreviewWidth = displaySize.y
                    maxPreviewHeight = displaySize.x
                }

                if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {
                    maxPreviewWidth = MAX_PREVIEW_WIDTH
                }

                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {
                    maxPreviewHeight = MAX_PREVIEW_HEIGHT
                }
                Log.d(TAG, "setUpCameraOutputs: max preview width: $maxPreviewWidth")
                Log.d(TAG, "setUpCameraOutputs: max preview height: $maxPreviewHeight")
                mImageReader = ImageReader.newInstance(
                    largest!!.width, largest.height,
                    ImageFormat.JPEG,  /*maxImages*/2
                ).apply {
                    setOnImageAvailableListener(
                        mOnImageAvailableListener, mBackgroundHandler
                    )
                }
                mPreviewSize = Utility.chooseOptimalSize(
                    map.getOutputSizes(SurfaceTexture::class.java),
                    rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                    maxPreviewHeight, largest
                )
                Log.d(TAG, "setUpCameraOutputs: preview width: " + mPreviewSize!!.width)
                Log.d(TAG, "setUpCameraOutputs: preview height: " + mPreviewSize!!.height)

                val orientation = resources.configuration.orientation
                if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
                    mTextureView.setAspectRatio(
                        mPreviewSize!!.width, mPreviewSize!!.height, SCREEN_WIDTH, SCREEN_HEIGHT
                    )
                } else {
                    mTextureView.setAspectRatio(
                        mPreviewSize!!.height, mPreviewSize!!.width, SCREEN_HEIGHT, SCREEN_WIDTH
                    )
                }
                Log.d(TAG, "setUpCameraOutputs: cameraId: $mCameraId")
                // Check if the flash is supported.
                val available = characteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE)
                mFlashSupported = available ?: false
            }!!

        }catch (e: CameraAccessException){
            Log.d(TAG, "setUpCameraOutputs: ${e.message}")
        }catch (e: NullPointerException){
            // Currently an NPE is thrown when the Camera2API is used but not supported on the
            // device this code runs.
            ErrorDialog.newInstance(getString(R.string.camera_error)).show(
                childFragmentManager,
                FRAGMENT_DIALOG
            )
        }
    }

    /**
     * This a callback object for the [ImageReader]. "onImageAvailable" will be called when a
     * still image is ready to be saved.
     */
    private var mOnImageAvailableListener = ImageReader.OnImageAvailableListener {
        Log.d(TAG, "onImageAvailable: called.")
        if (!mIsImageAvailable) {
            mCapturedImage = it.acquireLatestImage()

            Log.d(TAG, "onImageAvailable: captured image width: ${it.acquireLatestImage().width}")
            Log.d(
                TAG,
                "onImageAvailable: captured image height:  ${it.acquireLatestImage().height}"
            )
            saveTempImageToStorage()
            (mContext as Activity).runOnUiThread(Runnable {
                Glide.with(activity!!)
                    .load(mCapturedImage)
                    .into(mStillShotImageView)

                showStillshotContainer()
            })
        }
    }

    /** set up and save cameraId */
    private fun findCameraIds(manager: CameraManager){
        try {
            for (cameraId: String in manager.cameraIdList){
                Log.d(TAG, "findCameraIds: CAMERA ID: $cameraId")
                val facing: CameraCharacteristics = manager.getCameraCharacteristics(cameraId)

                if(facing.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT){
                    mIMainActivity.setFrontCameraId(cameraId)
                }else if (facing.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK){
                    mIMainActivity.setBackCameraId(cameraId)
                }
            }
            mIMainActivity.setCameraFrontFacing()
            mCameraId = mIMainActivity.getFrontCameraId()
        }catch (e: CameraAccessException){
            Log.d(TAG, "findCameraIds: ${e.message}")
        }
    }

    private fun configureTransform(width: Int, height: Int){

    }

    private fun saveTempImageToStorage(){

    }

    private fun showStillshotContainer(){

    }
    /**
     * Initiate a still image capture.
     */
    private fun takePicture() { lockFocus() }

    /** Lock the focus as the first step for a still image capture.*/
    private fun lockFocus(){
        try{
            // This is how to tell the camera to lock focus.
        }catch (e: CameraAccessException){
            Log.d(TAG, e.message.toString())
        }
    }

    /**
     * Unlock the focus. This method should be called when still image capture sequence is
     * finished.
     */
    private fun unlockFocus(){

    }

    /** [CameraDevice.StateCallback] is called when [CameraDevice] changes its state.*/
    private val mStateCallback = object: CameraDevice.StateCallback(){
        override fun onOpened(camera: CameraDevice) {
            // This method is called when the camera is opened.  We start camera preview here.
            mCameraOpenCloseLock.release()
            mCameraDevice = camera
        }

        override fun onDisconnected(camera: CameraDevice) {
            mCameraOpenCloseLock.release()
            camera.close()
            mCameraDevice = null
        }

        override fun onError(camera: CameraDevice, error: Int) {
            Log.d(TAG, "mStateCallback --- onError: $error")
            mCameraOpenCloseLock.release()
            camera.close()
            mCameraDevice = null

        }

    }

    /**
     * [TextureView.SurfaceTextureListener] handles several lifecycle events on a
     * [ScalingTextureView].
     */
    private val mSurfaceTextureListener = object : SurfaceTextureListener {
        override fun onSurfaceTextureAvailable(texture: SurfaceTexture, width: Int, height: Int) {
        }

        override fun onSurfaceTextureSizeChanged(texture: SurfaceTexture, width: Int, height: Int) {
        }

        override fun onSurfaceTextureDestroyed(texture: SurfaceTexture): Boolean = true

        override fun onSurfaceTextureUpdated(texture: SurfaceTexture) {}
    }
    private enum class State{
        /** Camera state: Showing camera preview. */
        PREVIEW,
        /** Camera state: Waiting for the focus to be locked. */
        WAITING_LOCK,
        /** Camera state: Waiting for the exposure to be pre capture state. */
        WAITING_PRE_CAPTURE,
        /** Camera state: Waiting for the exposure state to be something other than precapture. */
        WAITING_NON_PRE_CAPTURE,
        /** Camera state: Picture was taken. */
        PICTURE_TAKEN
    }
    /** States for the flash */
    private enum class Flash{
        ON, OFF, AUTO
    }
    companion object{
        private const val TAG = "CameraFragment"
        private const val REQUEST_CAMERA_PERMISSION = 1
        private const val FRAGMENT_DIALOG = "dialog"
        private val ORIENTATIONS = SparseIntArray().apply {
            append(Surface.ROTATION_0, 90)
            append(Surface.ROTATION_90, 0)
            append(Surface.ROTATION_180, 270)
            append(Surface.ROTATION_270, 180)
        }

        /** Time it takes for icons to fade (in milliseconds)  */
        private const val ICON_FADE_DURATION = 400
        /** The current state of camera state for taking pictures.
         * @see .mCaptureCallback
         */
        private val mState: State = State.PREVIEW
        fun newInstance(): Fragment { return CameraFragment() }
    }
    override fun onClick(view: View) {
        when(view){
            mBinding.stillshot -> {

            }
            mBinding.flashToggle -> {

            }
            mBinding.switchOrientation -> {

            }
        }
    }

    override fun onTouch(view: View, event: MotionEvent): Boolean {
        TODO("Not yet implemented")
    }

}